/**
 * Farcaster Intelligence API - Fetches live token data from Python analyzers
 * Connects to Python analysis scripts and formats data for frontend
 */

import { promises as fs } from 'fs';
import { NextResponse } from 'next/server';
import path from 'path';

export const dynamic = 'force-dynamic';

interface TokenData {
    symbol: string;
    price: number;
    change24h: number;
    volume24h: number;
    liquidity: number;
    castCount: number;
    likes: number;
    engagement: number;
    score: number;
    rating: string;
    recommendation: string;
    lastUpdate: string;
}

// Top Farcaster tokens to analyze
const FARCASTER_TOKENS = [
    'DEGEN', 'HIGHER', 'BUILD', 'TN100x', 'BEAN',
    'NORMIE', 'BRETT', 'VOT', 'MOXIE', 'ENJOY'
];

export async function GET() {
    try {
        console.log('üß† Fetching Farcaster Intelligence...');

        const tokens: TokenData[] = [];

        // Try to load from cached intelligence files (generated by Python scripts)
        const intelligenceCachePath = path.join(process.cwd(), '..', 'VOT_Trading_Bot', 'intelligence_cache');

        for (const symbol of FARCASTER_TOKENS) {
            try {
                // Look for recent analysis files
                const analysisFiles = [
                    `${symbol.toLowerCase()}_intelligence.json`,
                    `${symbol.toLowerCase()}_analysis.json`,
                    `${symbol}_intelligence.json`,
                    `${symbol}_analysis.json`
                ];

                let tokenData: Record<string, unknown> | null = null;

                for (const filename of analysisFiles) {
                    try {
                        const filePath = path.join(intelligenceCachePath, filename);
                        const fileContent = await fs.readFile(filePath, 'utf-8');
                        tokenData = JSON.parse(fileContent);
                        break;
                    } catch {
                        continue;
                    }
                }

                if (tokenData) {
                    // Extract data from the new analysis structure
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    const summary: Record<string, any> = (tokenData as any).summary || {};
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    const fullAnalysis: Record<string, any> = (tokenData as any).full_analysis || {};
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    const marketData: Record<string, any> = fullAnalysis.market_data || {};
                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
                    const farcasterData: Record<string, any> = fullAnalysis.farcaster_intelligence || {};

                    tokens.push({
                        symbol: symbol,
                        price: parseFloat(summary.price || marketData.price || 0),
                        change24h: parseFloat(summary.price_change_24h || marketData.price_change_24h || 0),
                        volume24h: parseFloat(summary.volume_24h || marketData.volume_24h || 0),
                        liquidity: parseFloat(summary.liquidity || marketData.liquidity_usd || 0),
                        castCount: parseInt(summary.cast_count || farcasterData.mentions_24h || 0),
                        likes: parseInt(summary.total_likes || farcasterData.total_likes || 0),
                        engagement: parseFloat(summary.avg_engagement || farcasterData.sentiment_score || 0) * 10,
                        score: parseInt(summary.intelligence_score || 50),
                        rating: summary.rating || 'MODERATE',
                        recommendation: summary.recommendation || 'Active monitoring recommended',
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        lastUpdate: (tokenData as any).metadata?.timestamp || new Date().toISOString()
                    });
                } else {
                    console.warn(`‚ö†Ô∏è No intelligence data found for ${symbol}`);
                }
            } catch (error) {
                console.warn(`‚ö†Ô∏è Failed to load data for ${symbol}:`, error);
            }
        }

        // Sort by score (highest first)
        tokens.sort((a, b) => b.score - a.score);

        if (tokens.length === 0) {
            return NextResponse.json({
                success: false,
                tokens: [],
                error: 'MCPVOT agent upgrading.',
                timestamp: new Date().toISOString(),
                message: 'MCPVOT agent upgrading.'
            }, { status: 503 });
        }

        return NextResponse.json({
            success: true,
            tokens: tokens,
            timestamp: new Date().toISOString(),
            source: 'python_analyzers',
            nextUpdate: new Date(Date.now() + 3600000).toISOString() // 1 hour
        });

    } catch (error) {
        console.error('‚ùå Farcaster Intelligence API Error:', error);

        return NextResponse.json({
            success: false,
            tokens: [],
            error: 'MCPVOT agent upgrading.',
            message: 'MCPVOT agent upgrading.',
            timestamp: new Date().toISOString()
        }, { status: 503 });
    }
}
